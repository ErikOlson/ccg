#!/bin/sh
# ccg — Claude Code Git
# Thin POSIX sh wrapper around pgit, purpose-built for Claude Code users.

set -e

CCG_VERSION="0.1.0"

# Verify pgit is available.
if ! command -v pgit >/dev/null 2>&1; then
    echo "ccg: pgit not found on PATH. Install pgit first." >&2
    exit 1
fi

# Walk up from $PWD to find the .pgit root.
# On success, sets CCG_ROOT and CCG_PGIT_DIR.
ccg_find_root() {
    _d="$PWD"
    while [ "$_d" != "/" ]; do
        if [ -d "$_d/.pgit" ]; then
            CCG_ROOT="$_d"
            CCG_PGIT_DIR="$_d/.pgit"
            return 0
        fi
        _d="$(dirname "$_d")"
    done
    return 1
}

ccg_require_root() {
    if ! ccg_find_root; then
        echo "ccg: not a ccg directory (no .pgit/ found). Run 'ccg init' first." >&2
        exit 1
    fi
}

# ccg commit: product gets the user's message; process gets sync: product@<hash>.
# If only process has staged changes (no product commit), use the message directly.
ccg_commit() {
    # Parse -m value
    _msg=""
    _skip=false
    for _arg in "$@"; do
        if $_skip; then
            _msg="$_arg"
            _skip=false
            continue
        fi
        case "$_arg" in
            -m) _skip=true ;;
            -m*) _msg="${_arg#-m}" ;;
        esac
    done

    if [ -z "$_msg" ]; then
        echo "ccg: -m <message> is required" >&2
        exit 1
    fi

    ccg_require_root

    _prod_dir="$CCG_ROOT/.git"
    _proc_dir="$CCG_PGIT_DIR/layers/process/.git"
    _work="$CCG_ROOT"

    # Detect staged changes in each repo
    _product_staged=false
    _process_staged=false

    if ! git --git-dir="$_prod_dir" --work-tree="$_work" diff --cached --quiet 2>/dev/null; then
        _product_staged=true
    fi
    if ! git --git-dir="$_proc_dir" --work-tree="$_work" diff --cached --quiet 2>/dev/null; then
        _process_staged=true
    fi

    if ! $_product_staged && ! $_process_staged; then
        echo "ccg: nothing to commit" >&2
        exit 1
    fi

    # Commit product first, then derive the process message from its hash
    if $_product_staged; then
        git --git-dir="$_prod_dir" --work-tree="$_work" commit -m "$_msg"
        _hash=$(git --git-dir="$_prod_dir" rev-parse --short HEAD)
        _proc_msg="sync: product@$_hash"
    else
        # No product commit — use user's message directly for process
        _proc_msg="$_msg"
    fi

    if $_process_staged; then
        git --git-dir="$_proc_dir" --work-tree="$_work" commit -m "$_proc_msg"
    fi
}

# ccg remote: create GitHub repos with correct visibility and wire remotes.
ccg_remote() {
    ccg_require_root

    if ! command -v gh >/dev/null 2>&1; then
        echo "ccg: gh (GitHub CLI) is required for 'ccg remote'." >&2
        echo "  Install: https://cli.github.com" >&2
        exit 1
    fi

    if ! gh auth status >/dev/null 2>&1; then
        echo "ccg: not logged into GitHub. Run: gh auth login" >&2
        exit 1
    fi

    _name="$(basename "$CCG_ROOT")"
    _claude_name="${_name}-claude"
    _prod_dir="$CCG_ROOT/.git"
    _proc_dir="$CCG_PGIT_DIR/layers/process/.git"
    _owner=$(gh api user --jq .login)

    _product_remote=$(git --git-dir="$_prod_dir" remote get-url origin 2>/dev/null || true)
    _process_remote=$(git --git-dir="$_proc_dir" remote get-url origin 2>/dev/null || true)

    if [ -n "$_product_remote" ] && [ -n "$_process_remote" ]; then
        echo "ccg: remotes already configured."
        echo "  product: $_product_remote"
        echo "  claude:  $_process_remote"
        exit 0
    fi

    # Create claude repo FIRST so product ends up on top in GitHub's activity sort
    # (most recently created/pushed repo appears first in the list).
    if [ -z "$_process_remote" ]; then
        echo "ccg: creating private claude repo '$_claude_name'..."
        gh repo create "$_claude_name" --private
    fi

    # Create product repo second — it becomes the most recently active and sits on top.
    if [ -z "$_product_remote" ]; then
        echo "ccg: creating public product repo '$_name'..."
        gh repo create "$_name" --public --source="$CCG_ROOT" --push
    fi

    # Wire claude remote now that product URL exists for SSH vs HTTPS detection.
    if [ -z "$_process_remote" ]; then
        _prod_url=$(git --git-dir="$_prod_dir" remote get-url origin 2>/dev/null || true)
        case "$_prod_url" in
            git@*) _proc_url="git@github.com:$_owner/$_claude_name.git" ;;
            *)     _proc_url="https://github.com/$_owner/$_claude_name.git" ;;
        esac
        git --git-dir="$_proc_dir" remote add origin "$_proc_url"

        if git --git-dir="$_proc_dir" rev-parse HEAD >/dev/null 2>&1; then
            git --git-dir="$_proc_dir" --work-tree="$CCG_ROOT" push -u origin HEAD
        fi
    fi

    echo "ccg: remotes configured."
    echo "  product: $(git --git-dir="$_prod_dir" remote get-url origin 2>/dev/null || echo '(not set)')"
    echo "  claude:  $(git --git-dir="$_proc_dir" remote get-url origin 2>/dev/null || echo '(not set)')"
}

# ccg overview (no args): branch, clean/dirty, last commit for both repos.
ccg_overview() {
    ccg_require_root

    _prod_dir="$CCG_ROOT/.git"
    _proc_dir="$CCG_PGIT_DIR/layers/process/.git"
    _work="$CCG_ROOT"

    _prod_branch=$(git --git-dir="$_prod_dir" rev-parse --abbrev-ref HEAD 2>/dev/null || echo "no commits")
    _proc_branch=$(git --git-dir="$_proc_dir" rev-parse --abbrev-ref HEAD 2>/dev/null || echo "no commits")

    if git --git-dir="$_prod_dir" --work-tree="$_work" diff --quiet 2>/dev/null && \
       git --git-dir="$_prod_dir" --work-tree="$_work" diff --cached --quiet 2>/dev/null; then
        _prod_status="clean"
    else
        _prod_status="dirty"
    fi

    if git --git-dir="$_proc_dir" --work-tree="$_work" diff --quiet 2>/dev/null && \
       git --git-dir="$_proc_dir" --work-tree="$_work" diff --cached --quiet 2>/dev/null; then
        _proc_status="clean"
    else
        _proc_status="dirty"
    fi

    _prod_commit=$(git --git-dir="$_prod_dir" log --oneline -1 2>/dev/null || echo "(no commits)")
    _proc_commit=$(git --git-dir="$_proc_dir" log --oneline -1 2>/dev/null || echo "(no commits)")

    echo "product repo  [$_prod_branch] $_prod_status"
    echo "  $_prod_commit"
    echo "claude repo   [$_proc_branch] $_proc_status"
    echo "  $_proc_commit"
}

# ccg push: push both repos if remotes are configured.
ccg_push() {
    ccg_require_root

    _prod_dir="$CCG_ROOT/.git"
    _proc_dir="$CCG_PGIT_DIR/layers/process/.git"
    _work="$CCG_ROOT"

    _product_remote=$(git --git-dir="$_prod_dir" remote get-url origin 2>/dev/null || true)
    _process_remote=$(git --git-dir="$_proc_dir" remote get-url origin 2>/dev/null || true)

    if [ -z "$_product_remote" ] && [ -z "$_process_remote" ]; then
        echo "ccg: no remotes configured. Run 'ccg remote' first." >&2
        exit 1
    fi

    if [ -n "$_product_remote" ]; then
        git --git-dir="$_prod_dir" --work-tree="$_work" push -u origin HEAD
    fi

    if [ -n "$_process_remote" ]; then
        git --git-dir="$_proc_dir" --work-tree="$_work" push -u origin HEAD
    fi
}

# --- Main dispatch ---

case "${1:-}" in
    --version|-V)
        echo "ccg $CCG_VERSION"
        exit 0
        ;;
    --help|-h|help)
        cat <<'EOF'
ccg — Claude Code Git

Keep Claude Code files out of your product repo. Two repos, one working
directory: product (public) and claude (private).

Usage: ccg <command>

Commands:
  init           Set up Claude Code process separation in current directory
  add [files]    Stage files — auto-routes each file to product or claude repo
  status         Show status of both repos
  commit -m MSG  Commit both repos with one message
  push           Push both repos to GitHub
  remote         Create GitHub repos (public product, private claude)

Examples:
  ccg init                    # new project — creates both repos
  ccg add .                   # stage everything, correctly routed
  ccg commit -m "add login"   # product gets your message, claude gets a hash ref
  ccg remote                  # one command to set up GitHub
  ccg push                    # push both

Run 'ccg' with no arguments for a quick overview.
EOF
        exit 0
        ;;
    init)
        shift
        # ccg owns its Claude Code pattern set — write it explicitly so we
        # don't depend on the installed pgit version's registry defaults.
        _reg="${XDG_CONFIG_HOME:-$HOME/.config}/pgit/patterns"
        mkdir -p "$_reg"
        cat > "$_reg/claude-code.json" << 'PATTERNS'
{
  "name": "claude-code",
  "description": "Claude Code process files",
  "patterns": [
    "CLAUDE.md",
    ".claude/",
    ".claudeignore",
    "AGENTS.md",
    "PLAN.md",
    "TASKS.md"
  ]
}
PATTERNS
        pgit init "$@" >/dev/null
        cat <<'EOF'
ccg: you're set up.

  Claude repo (private): CLAUDE.md, .claude/, PLAN.md, TASKS.md, AGENTS.md
  Product repo (public): everything else

Next:
  ccg add .          stage your files
  ccg commit -m MSG  commit both repos
  ccg remote         create GitHub repos (public + private)
EOF
        exit 0
        ;;
    add)
        shift
        pgit add "$@"
        exit 0
        ;;
    status)
        ccg_require_root
        echo "=== product repo ==="
        git --git-dir="$CCG_ROOT/.git" --work-tree="$CCG_ROOT" status
        echo ""
        echo "=== claude repo ==="
        git --git-dir="$CCG_PGIT_DIR/layers/process/.git" --work-tree="$CCG_ROOT" status
        exit 0
        ;;
    commit)
        shift
        ccg_commit "$@"
        exit 0
        ;;
    push)
        ccg_push
        exit 0
        ;;
    remote)
        ccg_remote
        exit 0
        ;;
    "")
        ccg_overview
        exit 0
        ;;
    *)
        echo "ccg: unknown command '$1'. Run 'ccg --help' for usage." >&2
        exit 1
        ;;
esac
